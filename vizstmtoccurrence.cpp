#include "oslutils.h"
#include "vizstatement.h"
#include "vizstmtoccurrence.h"

#include <functional>

VizStmtOccurrence::VizStmtOccurrence(osl_statement_p stmt, const std::vector<int> &betaVector,
                                     VizStatement *parent) :
  QObject(parent), m_oslStatement(stmt), m_statement(parent) {
  oslListForeach(stmt->scattering, [this,&betaVector](osl_relation_p scattering) {
    if (betaExtract(scattering) == betaVector) {
      m_oslScatterings.push_back(scattering);
    }
  });
  CLINT_ASSERT(m_oslScatterings.size() != 0,
               "Trying to create an occurrence for the inexistent beta-vector");

  m_betaVector.reserve(betaVector.size());
  std::copy(std::begin(betaVector), std::end(betaVector), std::back_inserter(m_betaVector));
}

bool operator < (const VizStmtOccurrence &lhs, const VizStmtOccurrence &rhs) {
  return lhs.m_betaVector < rhs.m_betaVector;
}

bool operator ==(const VizStmtOccurrence &lhs, const VizStmtOccurrence &rhs) {
  return lhs.m_betaVector == rhs.m_betaVector;
}

std::vector<std::vector<int>> VizStmtOccurrence::projectOn(int horizontalDimIdx, int verticalDimIdx) const {
  // Transform iterator (alpha only) indices to enumerator (beta-alpha-beta) indices
  // betaDims are found properly iff the dimensionalityChecker assertion holds.
  int horizontalDimOsl    = 1 + 2 * horizontalDimIdx;
  int verticalDimOsl      = 1 + 2 * verticalDimIdx;
  int horizontalBetaDim   = 1 + 2 * m_oslStatement->domain->nb_output_dims + horizontalDimIdx;
  int verticalBetaDim     = 1 + 2 * m_oslStatement->domain->nb_output_dims + verticalDimIdx;
  // Checking if all the relations for the same beta have the same structure.
  // AZ: Not sure if it is theoretically possible: statements with the same beta-vector
  // should normally be in the same part of the domain union and therefore have same
  // number of scattering variables.  If the following assertion ever fails, check the
  // theoretical statement and if it does not hold, perform enumeration separately for
  // each union part.
  // AZ: this holds for SCoPs generated by Clan.
  // TODO: piggyback on oslUtils and Enumerator to pass around the mapping from original iterators
  // to the scattering (indices in applied matrix) since different parts of the domain and scattering
  // relation unions may have different number of input/output dimensions for the codes
  // originating from outside Clan/Clay toolset.
  auto dimensionalityCheckerFunction = [](osl_relation_p rel, int output_dims,
                                          int input_dims, int parameters) {
    CLINT_ASSERT(rel->nb_output_dims == output_dims,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
    CLINT_ASSERT(rel->nb_input_dims == input_dims,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
    CLINT_ASSERT(rel->nb_parameters == parameters,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
  };
  oslListForeach(m_oslStatement->domain, dimensionalityCheckerFunction, m_oslStatement->domain->nb_output_dims,
                 m_oslStatement->domain->nb_input_dims, m_oslStatement->domain->nb_parameters);
  std::for_each(std::begin(m_oslScatterings), std::end(m_oslScatterings),
                std::bind(dimensionalityCheckerFunction, std::placeholders::_1,
                          m_oslScatterings.front()->nb_output_dims,
                          m_oslScatterings.front()->nb_input_dims,
                          m_oslScatterings.front()->nb_parameters));

  // Get original and scattered iterator values depending on the axis displayed.
  std::vector<int> visibleDimensions;
  bool projectHorizontal = dimensionality() > horizontalDimIdx;
  bool projectVertical   = dimensionality() > verticalDimIdx;
  if (!projectHorizontal && !projectVertical) {
    // This is just a point, no actual enumeration needed.
    // All the dimensions being projected out, the result of enumeration is a single zero-dimensional point.
  } else if (projectHorizontal && !projectVertical) {
    visibleDimensions.push_back(horizontalDimOsl);
    visibleDimensions.push_back(horizontalBetaDim);
  } else if (!projectHorizontal && projectVertical) {
    visibleDimensions.push_back(verticalDimOsl);
    visibleDimensions.push_back(verticalBetaDim);
  } else {
    visibleDimensions.push_back(horizontalDimOsl);
    visibleDimensions.push_back(verticalDimOsl);
    visibleDimensions.push_back(horizontalBetaDim);
    visibleDimensions.push_back(verticalBetaDim);
  }

  // TODO: we do not need the beta-filter anymore, since the scatterings that match the
  // current beta are already filtered and stored in m_oslScatterings.
  osl_relation_p applied = oslApplyScattering(m_oslStatement, m_betaVector);
  osl_relation_p ready = oslRelationsWithContext(applied, m_statement->scop()->fixedContext());

  std::vector<std::vector<int>> points =
      program()->enumerator()->enumerate(ready, std::move(visibleDimensions));

  return std::move(points);
}
