#include "oslutils.h"
#include "clintstmt.h"
#include "clintstmtoccurrence.h"

#include <functional>

ClintStmtOccurrence::ClintStmtOccurrence(osl_statement_p stmt, const std::vector<int> &betaVector,
                                     ClintStmt *parent) :
  QObject(parent), m_oslStatement(stmt), m_statement(parent) {
  oslListForeach(stmt->scattering, [this,&betaVector](osl_relation_p scattering) {
    if (betaExtract(scattering) == betaVector) {
      m_oslScatterings.push_back(scattering);
    }
  });
  CLINT_ASSERT(m_oslScatterings.size() != 0,
               "Trying to create an occurrence for the inexistent beta-vector");

  m_betaVector.reserve(betaVector.size());
  std::copy(std::begin(betaVector), std::end(betaVector), std::back_inserter(m_betaVector));

  // FIXME: -2 is a value for NO_DIMENSION from VizCoordinateSystem.  Promote.
  m_cachedDimMins[-2] = 0;
  m_cachedDimMaxs[-2] = 0;
}

bool operator < (const ClintStmtOccurrence &lhs, const ClintStmtOccurrence &rhs) {
  return lhs.m_betaVector < rhs.m_betaVector;
}

bool operator ==(const ClintStmtOccurrence &lhs, const ClintStmtOccurrence &rhs) {
  return lhs.m_betaVector == rhs.m_betaVector;
}

std::vector<std::vector<int>> ClintStmtOccurrence::projectOn(int horizontalDimIdx, int verticalDimIdx) const {
  // Transform iterator (alpha only) indices to enumerator (beta-alpha-beta) indices
  // betaDims are found properly iff the dimensionalityChecker assertion holds.
  int horizontalDimOsl    = 1 + 2 * horizontalDimIdx;
  int verticalDimOsl      = 1 + 2 * verticalDimIdx;
  int horizontalBetaDim   = 1 + 2 * m_oslStatement->domain->nb_output_dims + horizontalDimIdx;
  int verticalBetaDim     = 1 + 2 * m_oslStatement->domain->nb_output_dims + verticalDimIdx;
  // Checking if all the relations for the same beta have the same structure.
  // AZ: Not sure if it is theoretically possible: statements with the same beta-vector
  // should normally be in the same part of the domain union and therefore have same
  // number of scattering variables.  If the following assertion ever fails, check the
  // theoretical statement and if it does not hold, perform enumeration separately for
  // each union part.
  // AZ: this holds for SCoPs generated by Clan.
  // TODO: piggyback on oslUtils and Enumerator to pass around the mapping from original iterators
  // to the scattering (indices in applied matrix) since different parts of the domain and scattering
  // relation unions may have different number of input/output dimensions for the codes
  // originating from outside Clan/Clay toolset.
  auto dimensionalityCheckerFunction = [](osl_relation_p rel, int output_dims,
                                          int input_dims, int parameters) {
    CLINT_ASSERT(rel->nb_output_dims == output_dims,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
    CLINT_ASSERT(rel->nb_input_dims == input_dims,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
    CLINT_ASSERT(rel->nb_parameters == parameters,
                 "Dimensionality mismatch, proper polyhedron construction impossible");
  };
  oslListForeach(m_oslStatement->domain, dimensionalityCheckerFunction, m_oslStatement->domain->nb_output_dims,
                 m_oslStatement->domain->nb_input_dims, m_oslStatement->domain->nb_parameters);
  std::for_each(std::begin(m_oslScatterings), std::end(m_oslScatterings),
                std::bind(dimensionalityCheckerFunction, std::placeholders::_1,
                          m_oslScatterings.front()->nb_output_dims,
                          m_oslScatterings.front()->nb_input_dims,
                          m_oslScatterings.front()->nb_parameters));

  // Get original and scattered iterator values depending on the axis displayed.
  std::vector<int> visibleDimensions;
  bool projectHorizontal = dimensionality() > horizontalDimIdx;
  bool projectVertical   = dimensionality() > verticalDimIdx;
  if (!projectHorizontal && !projectVertical) {
    // This is just a point, no actual enumeration needed.
    // All the dimensions being projected out, the result of enumeration is a single zero-dimensional point.
  } else if (projectHorizontal && !projectVertical) {
    visibleDimensions.push_back(horizontalDimOsl);
    visibleDimensions.push_back(horizontalBetaDim);
  } else if (!projectHorizontal && projectVertical) {
    visibleDimensions.push_back(verticalDimOsl);
    visibleDimensions.push_back(verticalBetaDim);
  } else {
    visibleDimensions.push_back(horizontalDimOsl);
    visibleDimensions.push_back(verticalDimOsl);
    visibleDimensions.push_back(horizontalBetaDim);
    visibleDimensions.push_back(verticalBetaDim);
  }

  osl_relation_p applied = oslApplyScattering(oslListToVector(m_oslStatement->domain),
                                              m_oslScatterings);
  osl_relation_p ready = oslRelationsWithContext(applied, m_statement->scop()->fixedContext());

  std::vector<std::vector<int>> points =
      program()->enumerator()->enumerate(ready, std::move(visibleDimensions));
  computeMinMax(points, horizontalDimIdx, verticalDimIdx);

  return std::move(points);
}

void ClintStmtOccurrence::computeMinMax(const std::vector<std::vector<int>> &points,
                                      int horizontalDimIdx, int verticalDimIdx) const {
  // Initialize with extreme values for min and max unless already computed for previous polyhedron
  size_t pointSize = points.front().size();
  int horizontalMin, horizontalMax, verticalMin = 0, verticalMax = 0;
  if (horizontalDimIdx == -2) {
    return;
  }
  switch (pointSize) {
  case 4:
    verticalMin   = INT_MAX;
    verticalMax   = INT_MIN;
    // fall through
  case 2:
    horizontalMin = INT_MAX;
    horizontalMax = INT_MIN;
    break;
  case 0:
    return;
    break;
  default:
    CLINT_UNREACHABLE;
    break;
  }

  // Compute min and max values for projected iterators of the current coordinate system.
  for (const std::vector<int> &point : points) {
    CLINT_ASSERT(point.size() == pointSize,
                 "Enumerated points have different dimensionality");
    horizontalMin = std::min(horizontalMin, point[0]);
    horizontalMax = std::max(horizontalMax, point[0]);
    if (pointSize == 4) {
      verticalMin = std::min(verticalMin, point[1]);
      verticalMax = std::max(verticalMax, point[1]);
    }
  }
  CLINT_ASSERT(horizontalMin != INT_MIN, "Could not compute horizontal minimum");
  CLINT_ASSERT(horizontalMax != INT_MAX, "Could not compute horizontal maximum");
  CLINT_ASSERT(verticalMin != INT_MIN, "Could not compute vertical minimum");
  CLINT_ASSERT(verticalMax != INT_MAX, "Could not compute vertical maximum");

  m_cachedDimMins[horizontalDimIdx] = horizontalMin;
  m_cachedDimMaxs[horizontalDimIdx] = horizontalMax;
  if (pointSize == 4) {
    m_cachedDimMins[verticalDimIdx] = verticalMin;
    m_cachedDimMaxs[verticalDimIdx] = verticalMax;
  }
}

int ClintStmtOccurrence::minimumValue(int dimIdx) const {
  if (dimIdx >= dimensionality())
    return 0;
  if (m_cachedDimMins.count(dimIdx) == 0) {
    projectOn(dimIdx, INT_MAX);
  }
  CLINT_ASSERT(m_cachedDimMins.count(dimIdx) == 1,
               "min cache failure");
  return m_cachedDimMins[dimIdx];
}

int ClintStmtOccurrence::maximumValue(int dimIdx) const {
  if (dimIdx >= dimensionality())
    return 0;
  if (m_cachedDimMaxs.count(dimIdx) == 0) {
    projectOn(dimIdx, INT_MAX);
  }
  CLINT_ASSERT(m_cachedDimMaxs.count(dimIdx) == 1,
               "max cache failure");
  return m_cachedDimMaxs[dimIdx];
}
